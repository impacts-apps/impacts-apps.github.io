<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Impacts Simulator</title>

		<meta charset="utf-8">
		<meta name="description" content="Interactive 3D rendering of Earth bathymetry (underwater equivalent of land topography)"/>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black">
		 <link rel="icon" type="image/png" href="https://impacts.live/favicon.png">

		         <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2NRVS8C43B"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2NRVS8C43B');
</script>

		<style>
            body {
                color: #fff;
                font-family:Monospace;
                font-size:13px;
                font-weight: bold;
                background-color: #000;
                margin: 0px;
                padding: 0px;
                line-height: 1.5em;
            }
            /* Botão GO TO DASHBOARD */
            #dashboardBtn {
                position: fixed;
                bottom: 16px;
                right: 16px;
                background:#00cfff;
                color:#000;
                font-family: monospace, Arial, sans-serif;
                font-weight:600;
                letter-spacing:1px;
                border:none;
                padding:12px 22px;
                border-radius:6px;
                cursor:pointer;
                box-shadow:0 2px 6px rgba(0,0,0,0.4);
                z-index:2000;
                text-decoration:none;
                font-size:13px;
                transition:background .2s, transform .2s;
                user-select:none;
            }
            #dashboardBtn:hover,
            #dashboardBtn:focus {
                background:#19d9ff;
                outline:none;
                transform:translateY(-2px);
            }
            #dashboardBtn:active {
                transform:translateY(0);
            }
            @media (max-width:640px){
                #dashboardBtn {
                    padding:10px 18px;
                    font-size:12px;
                    bottom:10px;
                    right:10px;
                }
            }

		    #info {
				text-align:center;
				color:#fff;
				text-shadow:1px 1px 6px rgba(0,0,0,0.75);
				position: absolute;
				top: 0px; width: 100%;

				padding: 5px 0px;
				z-index: 100;
		    }

			.subinfo {
				color: rgba(255, 255, 255, 0.5);
				display: inline;
			}

			.key {
				color: rgba(255, 255, 255, 0.75);
			}

			#help {
				display: none;
			}

		    a { color: white; }

			#stats { position: absolute; bottom:0; left: 0 }
			#stats #fps { background: transparent !important }
			#stats #fps #fpsText { color: #666 !important }
			#stats #fps #fpsGraph { display: none }

			#loading { background: #0af; color: white; padding: 0.25em 1em; position: absolute; right:0px; top: 0px; z-index: 200; }
		</style>
	</head>

	<body>
        <div id="loading">Loading ...</div>
        <!-- Botão GO TO DASHBOARD -->
        <a id="dashboardBtn" href="../dashboard/" aria-label="Go to dashboard">GO TO DASHBOARD</a>
        <!-- AUDIO: simulador -->
        <audio id="simAudio" src="simulator.mp3" loop preload="auto" playsinline></audio>

		<div id="info">
			
			
			<div id="help"> Impactor 2025
			<span class="key">Z:</span> Zoom,
			
			
			<span class="key">P:</span> Ultra Quality
			</div>
			</div>
		</div>

        <script src="js/xg.min.eb2.js"></script>
        <script src="js/Config.js"></script>
        <!-- <script src="js/stats.min.js"></script> --> <!-- removido para tirar FPS -->
        <script src="js/Meteor.js"></script>
        <script src="js/ImpactUI.js"></script>
        <script src="js/PopGrid.js"></script>
        <script src="js/ImpactResults.js"></script>
		 <script src="js/ResultEffects.js"></script>
		<script>
			var hasWebGL1 = Detector.webgl;
			var hasWebGL2 = Detector.webgl2;

			var loadingElement = document.getElementById( "loading" );
			var infoElement = document.getElementById( "info" );
			var helpElement = document.getElementById( "help" );

			var hudVisible = true;
			var useDeferred = true;

			if ( ! ( hasWebGL1 || hasWebGL2 ) ) {

				loadingElement.style.display = "none";
				infoElement.style.display = "none";

				Detector.addGetWebGLMessage();

			} else {

			var backend = hasWebGL2 ? "webgl2" : "webgl1";

			var isMobile = Detector.isMobile;

			if ( ! Detector.deferredCapable || isMobile ) useDeferred = false;

			if ( ! isMobile ) helpElement.style.display = "inline";

			var useMRT = true;

			// platform-specific compatibility fixes
			// (mostly things that are supposed to work but are broken anyways)

			var isChrome   = navigator.userAgent.toLowerCase().indexOf( "chrome" ) >= 0;
			var isSafari   = navigator.userAgent.toLowerCase().indexOf( "safari" ) >= 0 && ! isChrome;
			var isFirefox  = navigator.userAgent.toLowerCase().indexOf( "firefox" ) >= 0;
			var isExplorer = navigator.userAgent.toLowerCase().indexOf( "trident" ) >= 0;
			var isOSX 	   = navigator.platform.toLowerCase().indexOf( "mac" ) >= 0 && ! Detector.isIpadOS;
			var isIOS 	   = isSafari && ! isOSX;
			var isAndroid  = !! navigator.userAgent.match( /Android/i );

			// Chrome breaks with WebGL2
			// (array index for samplers must be constant integral expressions)

			backend = "webgl1";

			// Firefox on OSX fails with multiple-render-targets

			if ( isOSX && isFirefox ) useMRT = false;

			//

			var SCALE = 1.0 / window.devicePixelRatio;
            var MARGIN = 0;
            var BRIGHTNESS = 2;

            var SCREEN_WIDTH = window.innerWidth;
            var SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;

			var isUltra = false;
			var ULTRA_THRESHOLD = 4000;

			var isPhoto = false;

			//

			var rotationEnabled = true;

			var container, camera, scene;
			var innerRenderer;
			var renderer;

			var dirLight, hemiLight, dayLight;
			var meshRoot;

			var earthMaterial;
			var normalMapWater;

			var assets = {};
			var planets = [];
			var spheres = [];
			var currentLOD = 0;

			var fovIndex = 3;                     // 0..3 (3 corresponde a 30 no array abaixo)
var fovArray = [ 17.5, 10, 17.5, 30 ];

			var waterIndex = 0;
			var waterArray = [];

			// ui

			var loadCounter = 0;

			// camera controls

			var mouseX = 0;
			var mouseY = 0;

			var targetX = 0.0;
			var targetY = 0.0;
			var angle = 0.0;
			var height = 0.0;
			var target = new XG.Vector3();

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			//

			var clock = new XG.Clock();


			function init() {

				// performance presets

				var gpuDetector = new GPUDetector();
				gpuData = gpuDetector.detectGPU();

				//

				if ( gpuData && gpuData.rawScore >= ULTRA_THRESHOLD ) {

					SCALE = 1.0;
					currentLOD = 3;
					isUltra = true;

				} else {

					SCALE = 0.7 / window.devicePixelRatio;
					currentLOD = 2;
					isUltra = false;

				}

				var pars = {

					"width"		: SCREEN_WIDTH,
					"height"	: SCREEN_HEIGHT,
					"scale"		: SCALE,
					"antialias"	: true,
					"tonemapping": XG.PhotographicOperator,
					"brightness": BRIGHTNESS,
					"clearColor": 0x020202,
					"clearAlpha": 1.0,
					"dither" 	: true,
					"alpha"		: false,
					"useMultipleRenderTargets": useMRT,
					"backend"	: backend

				};

				var shadowMapN = 2;

				if ( isMobile ) {

					//pars[ "antialias" ] = false;
					//pars[ "devicePixelRatio" ] = 0.7;

					currentLOD = 1;
					shadowMapN = 1;

				}

				//

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// camera

				camera = new XG.PerspectiveCamera( 30, SCREEN_WIDTH / SCREEN_HEIGHT, 50, 1500 ); // antes 17.5
				camera.position.set( 0, 0, 400 );
				camera.updateProjectionMatrix();

				// scene

				scene = new XG.Scene();
				scene.add( camera );

				// lights

				dayLight = new XG.DayLight( 0xffffff );
				dayLight.position.set( 0, 0.5, 1 ).multiplyScalar( 500 );
				scene.add( dayLight );

				dayLight.sunIntensity = 1.5;

				dayLight.castShadow = true;
				dayLight.shadowDarkness = 1;

				dayLight.shadowMapWidth  = 1024 * shadowMapN;
				dayLight.shadowMapHeight = 1024 * shadowMapN;
				dayLight.shadowCameraNear = 5;
				dayLight.shadowCameraFar = 1500;

				var d = 75;
				dayLight.shadowCameraLeft = -d;
				dayLight.shadowCameraRight = d;
				dayLight.shadowCameraTop = d;
				dayLight.shadowCameraBottom = -d;

				dayLight.hemiIntensity = 0.5;
				dayLight.groundColor.setHSV( 0, 0, 0.5 );
				dayLight.skyColor.setHSV( 0, 0, 1 );


				// renderer
				if ( useDeferred ) {
					renderer = new XG.DeferredRenderer( pars );
				} else {
					renderer = new XG.ForwardRenderer( pars );
				}
				renderer.domElement.style.position = "absolute";
				renderer.domElement.style.top = MARGIN + "px";
				container.appendChild( renderer.domElement );

				//

				renderer.shadowMapEnabled = true;
				renderer.shadowMapSlopeDepthBias = true;
				renderer.shadowMapCullFace = XG.CullFaceNone;
				renderer.shadowMapType = XG.PCFSoftShadowMap;

				if ( ! ( isMobile || isOSX ) ) renderer.shadowMapUseDepthTextures = true;

				//renderer.shadowMapDebug = true;

				//

				innerRenderer = renderer;

				if ( renderer instanceof XG.DeferredRenderer ) {

					innerRenderer = renderer.renderer;
					renderer.ssaoEnabled = true;

				}

				// stats
				/*
				if (window.Stats) {
                   stats = new Stats();
                   container.appendChild(stats.domElement);
               } else {
                   stats = { update: function(){} };
               }
				*/
				// substitui por stub vazio
				stats = { update(){ } };

				// events

				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'keydown', onKeyDown, false );

				renderer.domElement.addEventListener( 'touchmove', onTouchMove, false );

				// content

				meshRoot = new XG.Node();
				meshRoot.rotation.y = -1.9;
				scene.add( meshRoot );

				var geo128 = new XG.SphereGeometry( 50, 128, 64 );
				var geo256 = new XG.SphereGeometry( 50, 256, 128 );
				var geo512 = new XG.SphereGeometry( 50, 512, 256 );
				var geo1024 = new XG.SphereGeometry( 50, 1024, 512 );
				var geo2048 = new XG.SphereGeometry( 50, 2048, 1024 );

				spheres[ 0 ] = geo128;
				spheres[ 1 ] = geo256;
				spheres[ 2 ] = geo512;
				spheres[ 3 ] = geo1024;
				spheres[ 4 ] = geo2048;

				if ( isMobile ) {

					var glossMap = XG.ImageUtils.loadTexture( "assets/bathymetry_gloss_2k.jpg", checkLoaded );
					var bumpMap = XG.ImageUtils.loadTexture( "assets/bathymetry_bw_composite_2k.jpg", checkLoaded );
					var diffuseMap = XG.ImageUtils.loadTexture( "assets/bathymetry_diffuse_2k.jpg", checkLoaded );

				} else {

					var glossMap = XG.ImageUtils.loadTexture( "assets/bathymetry_gloss_4k.jpg", checkLoaded );
					var bumpMap = XG.ImageUtils.loadTexture( "assets/bathymetry_bw_composite_4k.jpg", checkLoaded );
					var diffuseMap = XG.ImageUtils.loadTexture( "assets/bathymetry_diffuse_4k.jpg", checkLoaded );

				}
				normalMapWater = XG.ImageUtils.loadTexture( "assets/water-normal.jpg", checkLoaded );

				normalMapWater.wrapS = normalMapWater.wrapT = XG.RepeatWrapping;
				glossMap.wrapS = glossMap.wrapT = XG.RepeatWrapping;
				bumpMap.wrapS = bumpMap.wrapT = XG.RepeatWrapping;
				diffuseMap.wrapS = diffuseMap.wrapT = XG.RepeatWrapping;

				glossMap.anisotropy = 16;
				diffuseMap.anisotropy = 16;

				if ( ! isSafari ) {

					bumpMap.anisotropy = 16;
					normalMapWater.anisotropy = 16;

				}

				earthMaterial = new XG.PhongMaterial( {

					color: 0xffffff,
					map: diffuseMap,
					glossMap: glossMap,
					displacementMap: bumpMap,
					displacementScale: 10.0,
					shininess: 0.5

				} );

				if ( !isMobile ) {

					earthMaterial.bumpMap = bumpMap;
					earthMaterial.bumpScale = 0.5;

				}

				var geo = spheres[ currentLOD ];
				var planet = addPlanet( geo );
				planets[ currentLOD ] = planet;

				if ( isMobile ) {

					addWaterSimple();

				} else {

					addWaterFancy();

				}

				onWindowResize();

				// FORÇAR INICIAR EM ULTRA (equivalente a apertar U)
                setLOD(3);
                renderer.setScale(1.0);
                isUltra = true;

				// Inicializa módulo do meteoro (APÓS criar meshRoot / renderer / camera)
				if (window.Meteor) {
                    Meteor.init({ renderer, camera, meshRoot, target, Config });
                }
			}

			// ------------------------------------------------------------

			function checkLoaded() {

				loadCounter += 1;

				if ( loadCounter >= 4 ) {

					loadingElement.style.display = "none";

				}

			}

			function onDocumentMouseMove ( event ) {

				mouseX = ( event.clientX - windowHalfX ) * 1;
				mouseY = ( event.clientY - windowHalfY ) * 1;

			}

			function onTouchMove( event ) {

				event.preventDefault();

				var touches = event.touches;
				var touch = touches[ 0 ];

				mouseX = ( touch.clientX - windowHalfX ) * 1;
				mouseY = ( touch.clientY - windowHalfY ) * 1;

			}

			function onKeyDown ( event ) {

				switch ( event.keyCode ) {

					case 49: /*1*/
						setLOD( 0 );
						break;

					case 50: /*2*/
						setLOD( 1 );
						break;

					case 51: /*2*/
						setLOD( 2 );
						break;

					case 52: /*3*/
						setLOD( 3 );
						break;

					case 53: /*4*/
						setLOD( 4 );
						break;

					case 90: /*Z*/
						if ( !event.ctrlKey ) toggleZoom();
						break;

					case 82: /*R*/
						if ( !event.ctrlKey ) toggleRotation();
						break;

					case 87: /*W*/
						if ( !event.ctrlKey ) toggleWater();
						break;

					case 85: /*U*/
						if ( !event.ctrlKey ) toggleUltra();
						break;

					case 80: /*P*/
						if ( !event.ctrlKey ) togglePhoto();
						break;

					case 72: /*H*/
						toggleHUD();
						break;

				}

			}

			function toggleRotation() {

				rotationEnabled = !rotationEnabled;

			}

			function toggleZoom() {

				fovIndex = ( fovIndex + 1 ) % fovArray.length;
				camera.fov = fovArray[ fovIndex ];
				camera.updateProjectionMatrix();

			}

			function toggleWater() {

				waterIndex = ( waterIndex + 1 ) % waterArray.length;
				scene.heightFog = waterArray[ waterIndex ];

			}

			// ------------------------------------------------------------
function addWaterFancy() {

  // Azul forte com extinção espectral (R < G < B) → puxa pro azul
  var waterBlue = new XG.HeightFog({
    height: 1,
    visibilityDistance: 48.0,
    fadeSpeed: 0.8,
    // cores em 0–1
    shallowDepthColor: new XG.Color().setRGB(0.10, 0.48, 0.98), // raso bem azul
    deepDepthColor:    new XG.Color().setRGB(0.05, 0.10, 0.28), // profundo azul-escuro
    rgbExtinctionDistance: new XG.Vector3(6.0, 11.0, 30.0)      // R morre +rápido, B +lento
  });

  // usa só esse preset (evita alternar pra um parecido com o original)
  waterArray = [ waterBlue ];
  scene.heightFog = waterBlue;

  // ------------------------------------------------------------

  var mm = 2;
  var WATER_OPACITY = 0.78; // deixa o fundo contribuir com a cor

  var waterGeo = new XG.SphereGeometry(50, 256, 128);
  var innerRenderer = renderer instanceof XG.DeferredRenderer ? renderer.renderer : renderer;

  waterSurface = new XG.WaterSurface(innerRenderer, {
    clipBias: 0.0,
    textureWidth: 1024, textureHeight: 1024,
    specular: 0x050505,
    normalMap: normalMapWater,
    normalScale: 3,
    gloss: 0.9,
    repeat: [2 * mm, mm],
    opacity: WATER_OPACITY
  });

  var waterMaterial = waterSurface.material;
  waterMaterial.transparent = true;
  waterMaterial.defines["USE_REFLECTION"] = false;
  // TIRAR AGUA DELETE ABAIXO
  waterMaterial.defines["WATER_SURFACE_SPHERE"] = true;

  // Pequena refração: colore sem criar borda roxa
  waterMaterial.uniforms["refractionScale"].value = 0.006;
  waterMaterial.uniforms["globalLightScale"].value = 0.035;

  waterMaterial.isMirror = true;

  waterMesh = new XG.Mesh(waterGeo, waterMaterial);
  waterMesh.scale.multiplyScalar(1.11);
  waterMesh.receiveShadow = true;
  waterMesh.add(waterSurface);
  meshRoot.add(waterMesh);

  scene.properties.mirrors = [ waterSurface ];
}



			// ------------------------------------------------------------

			function addWaterSimple() {

				normalMapWater.repeat.set( 2, 1 ).multiplyScalar( 4 );

				var geometry = new XG.SphereGeometry( 50, 128, 64 );

				var waterMaterial = new XG.PhongMaterial( {

					color: 0x000000,
					specular: 0x111111,
					normalMap: normalMapWater,
					shininess: 512,
					transparent: true,
					opacity: 0.6

				} );

				waterMaterial.color.set(0x0066ff);

				waterMesh = new XG.Mesh( geometry, waterMaterial );
				waterMesh.scale.multiplyScalar( 1.11 );
				waterMesh.receiveShadow = true;

				meshRoot.add( waterMesh );

			}

			// ------------------------------------------------------------

			function addPlanet( geometry ) {

				var mesh = new XG.Mesh( geometry, earthMaterial );
				mesh.castShadow = true;
				mesh.receiveShadow = true;

				meshRoot.add( mesh );

				return mesh;

			}

			function setLOD( lod ) {

				if ( planets[ lod ] === undefined ) {

					var geometry = spheres[ lod ];
					var planet = addPlanet( geometry );

					planets[ lod ] = planet;

				}

				planets[ currentLOD ].visible = false;
				planets[ lod ].visible = true;

				currentLOD = lod;

			}

			// ------------------------------------------------------------

			function togglePhoto() {

				if ( !isPhoto ) {

					setLOD( 4 );
					renderer.setScale( 2.0 );

					infoElement.style.display = "none";
					hudVisible = false;

					isPhoto = true;

				} else {

					if ( !isUltra ) {

					 setLOD( 2 );
					 renderer.setScale( 0.7 / window.devicePixelRatio );

					} else {

						setLOD( 3 );
						renderer.setScale( 1.0 );

					}

					infoElement.style.display = "block";
					hudVisible = true;

					isPhoto = false;

				}

			}

			function toggleUltra() {

				if ( !isUltra ) {

					setLOD( 3 );
					renderer.setScale( 1.0 );
					isUltra = true;

				} else {

					setLOD( 2 );
					renderer.setScale( 0.7 / window.devicePixelRatio );
					isUltra = false;

				}

			}

			function toggleHUD() {

				if ( hudVisible ) {

					infoElement.style.display = "none";
					hudVisible = false;

				} else {

					infoElement.style.display = "block";
					hudVisible = true;

				}

			}


			// ------------------------------------------------------------

			// event handlers

			function onWindowResize ( event ) {

                if ( isMobile ) {
                    if ( window.innerWidth > window.innerHeight ) {
                        camera.fov = 17.5;
                    } else {
                        camera.fov = 30;
                    }
                }

                // Canvas em tela cheia
                SCREEN_WIDTH  = window.innerWidth;
                SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;

                renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

                // encosta no topo/esquerda
                renderer.domElement.style.left = MARGIN + "px";
                renderer.domElement.style.top  = MARGIN + "px";

                camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
                camera.updateProjectionMatrix();
            }

			// updates

			function animate() {

				requestAnimationFrame( animate );
				render();

				// stats.update(); // removido

			}

			function render() {
                var rawDelta = clock.getDelta();
                var delta = 0.125 * rawDelta;

                // Planeta aparenta menor movendo a câmera (sem escalar objetos)
                camera.position.set(0, 0, 400); // antes 200
                camera.lookAt( target );

                if (window.Meteor) Meteor.update(delta);
                renderer.render( scene, camera );
			}

			//

			init();
			animate();
        }  // <-- FECHA o 'else {' aberto no topo (linha após Detector.addGetWebGLMessage)
        </script>
		<!-- <script async src="js/libs/rabbit.js"></script> -->
	
<!-- Terra API: helpers to add/remove meshes and custom shaders later -->
<script>
// Expose some safe hooks for future edits.
// You can call these from the browser console or other scripts.
window.TERRA = {
  get root(){ return window.meshRoot || window.scene || null; },
  add(object){ if (this.root && object) { this.root.add(object); } },
  remove(object){ if (this.root && object) { this.root.remove(object); } },
  // Example factory: creates a basic Phong sphere you can add anywhere
  makeSphere(radius=2, color=0x66ccff){
    const geo = new XG.SphereGeometry(radius, 32, 32);
    const mat = new XG.PhongMaterial({ color });
    return new XG.Mesh(geo, mat);
  }
};
console.log("%cTERRA ready.","padding:4px;background:#0af;color:#fff");
</script>

<script>
// ------ Audio Setup (simulator.mp3) ---------------------------------
(function(){
  const audioEl = document.getElementById('simAudio');
  if(!audioEl) return;

  // Estado do controle exposto ao dat.GUI
  const audioControl = {
    enabled: true,
    volume: 0.5
  };

  audioEl.volume = audioControl.volume;

  let pendingUnmute = false;
  let triedPlay = false;

  function attemptPlay() {
    if (triedPlay) return;
    triedPlay = true;

    // 1ª tentativa: tocar já desmutado
    audioEl.muted = false;
    audioEl.play().then(()=>{
      // sucesso direto
    }).catch(()=>{
      // Falhou (provável bloqueio de autoplay). Tenta mutado.
      audioEl.muted = true;
      audioEl.play().then(()=>{
        // Marcamos para desmutar após primeira interação do usuário
        pendingUnmute = true;
      }).catch(()=>{
        // Mantém parado até interação
        triedPlay = false; // permite nova tentativa ao interagir
      });
    });
  }

  attemptPlay();

  function userInteractHandler() {
    if (pendingUnmute) {
      audioEl.muted = false;
      pendingUnmute = false;
    }
    if (!audioEl.paused && audioEl.muted === false) {
      // já ok
    } else if(audioControl.enabled) {
      attemptPlay();
    }
  }

  ['click','keydown','pointerdown','touchstart'].forEach(ev=>{
    window.addEventListener(ev, userInteractHandler, { once:false, passive:true });
  });

  // Funções para dat.GUI
  function updateEnabled(val){
    if(val){
      attemptPlay();
      audioEl.muted = false;
      audioEl.play().catch(()=>{ /* silencioso */ });
    } else {
      audioEl.pause();
    }
  }

  function updateVolume(v){
    audioEl.volume = v;
  }

  // Integra com dat.GUI já criado em ImpactUI (tenta várias vezes até existir)
  function attachToGUI(attempt=0){
    const guiRef = window.gui || (window.ImpactUI && (ImpactUI.gui || ImpactUI.getGUI && ImpactUI.getGUI()));
    if(!guiRef){
      if (attempt < 20) setTimeout(()=>attachToGUI(attempt+1), 300);
      return;
    }
    const folderName = 'Audio';
    let audioFolder = (guiRef.__folders && guiRef.__folders[folderName]) ? guiRef.__folders[folderName] : guiRef.addFolder(folderName);

    audioFolder.add(audioControl,'enabled').name('Som').onChange(updateEnabled);
    audioFolder.add(audioControl,'volume',0,1,0.01).name('Volume').onChange(updateVolume);
    audioFolder.open();
  }
  attachToGUI();
})();
</script>
</body>
</html>