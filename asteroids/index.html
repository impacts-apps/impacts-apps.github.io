<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Looking for Asteroids — dat.gui • v2</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <!-- Import maps (Three + OrbitControls + Lines + dat.gui) -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js" crossorigin="anonymous"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js",
      "three/examples/jsm/lines/Line2.js": "https://unpkg.com/three@0.158.0/examples/jsm/lines/Line2.js",
      "three/examples/jsm/lines/LineMaterial.js": "https://unpkg.com/three@0.158.0/examples/jsm/lines/LineMaterial.js",
      "three/examples/jsm/lines/LineGeometry.js": "https://unpkg.com/three@0.158.0/examples/jsm/lines/LineGeometry.js",
      "dat.gui": "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js"
    }
  }
  </script>

  <style>
    :root{ --bg:#04070a; --fg:#eaf2ff; --muted:#a7b3c7; --accent:#24D3FF; --lucy:#f6ad06; }
    *{ box-sizing:border-box }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; }
    #scene{ position:fixed; inset:0; }

    /* Info card (agora opcional) */
    .info{
      position:fixed; left:16px; bottom:16px; width:min(420px,94vw);
      background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.35));
      border:1px solid rgba(255,255,255,.14); border-radius:12px; padding:16px;
      backdrop-filter: blur(10px); z-index:10;
      display:none; /* fica OFF por padrão; toggle no dat.gui */
    }
    .info h2{ margin:0 0 2px; font:800 18px/1 Inter }
    .kv{ display:grid; grid-template-columns:auto 1fr; gap:4px 10px; margin-top:8px; font-size:13px }
    .kv div:nth-child(odd){ color:var(--muted) }
    .live{ font:700 11px/1 'Inter', sans-serif; color:var(--accent); letter-spacing:1px }

    /* dat.gui do lado ESQUERDO */
    .dg.ac{ z-index:12 !important; right:auto !important; left:16px !important; top:16px !important; }
  </style>
</head>
<body>
  <main id="scene" aria-label="Looking for Asteroids 3D canvas"></main>

  <!-- Caixa de seleção educativa (opcional; default: escondida) -->
  <section class="info" id="infoCard" role="status" aria-live="polite">
    <div class="live">SELEÇÃO</div>
    <h2 id="selTitle">Clique em uma região/asteroide</h2>
    <div class="kv" id="selGrid">
      <div>Região</div><div>—</div>
      <div>Composição típica</div><div>—</div>
      <div>Tamanho típico</div><div>—</div>
      <div>Densidade típica</div><div>—</div>
      <div>Notas</div><div>—</div>
    </div>
  </section>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { Line2 } from 'three/examples/jsm/lines/Line2.js';
    import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial.js';
    import { LineGeometry } from 'three/examples/jsm/lines/LineGeometry.js';
    import * as dat from 'dat.gui';

    // ---------- CENA ----------
    const AU = 2.0;                         // 1 AU = 2 unidades
    const container = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.75));
    renderer.setClearColor(0x04070a, 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.add(new THREE.AmbientLight(0x223344, 0.7));
    const sun = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), new THREE.MeshBasicMaterial({ color:0xffd06a }));
    scene.add(sun);
    const sunLight = new THREE.PointLight(0xfff0c1, 2.4, 0, 2);
    scene.add(sunLight);

    // Estrelas
    (function stars(){
      const g = new THREE.BufferGeometry();
      const N = 1800, arr = new Float32Array(N*3);
      for (let i=0;i<N;i++){
        const r = 320 + Math.random()*240, th=Math.acos(THREE.MathUtils.randFloatSpread(2)), ph=Math.random()*Math.PI*2;
        arr[3*i+0]= r*Math.sin(th)*Math.cos(ph);
        arr[3*i+1]= r*Math.cos(th)*0.25;
        arr[3*i+2]= r*Math.sin(th)*Math.sin(ph);
      }
      g.setAttribute('position', new THREE.BufferAttribute(arr,3));
      scene.add(new THREE.Points(g, new THREE.PointsMaterial({ size:0.7, color:0xbfd8ff, transparent:true, opacity:0.9, depthWrite:false })));
    })();

    // ---------- CÂMERAS ----------
    const camPersp = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
    camPersp.position.set(0, 16, 34);
    const ctlPersp = new OrbitControls(camPersp, renderer.domElement);
    ctlPersp.enableDamping = true; ctlPersp.dampingFactor = 0.06; ctlPersp.maxDistance = 400; ctlPersp.minDistance = 2;

    const orthoSize = 24;
    let camOrtho = new THREE.OrthographicCamera(-orthoSize*camPersp.aspect, orthoSize*camPersp.aspect, orthoSize, -orthoSize, -1000, 1000);
    camOrtho.position.set(0, 60, 0.0001);
    camOrtho.up.set(0,0,1);           // top view com Z para cima
    camOrtho.lookAt(0,0,0);
    const ctlOrtho = new OrbitControls(camOrtho, renderer.domElement);
    ctlOrtho.enableRotate = false; ctlOrtho.enableDamping = true; ctlOrtho.screenSpacePanning = true; ctlOrtho.zoomSpeed = 1.2;

    let camera = camPersp, controls = ctlPersp;
    function setCameraMode(mode){ if(mode==='Top (ortho)'){ camera=camOrtho; controls=ctlOrtho; } else { camera=camPersp; controls=ctlPersp; } onResize(); }

    // ---------- SPRITE CIRCULAR (asteroides arredondados) ----------
    function makeCircleSprite(size=64) {
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const g = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      g.addColorStop(0, 'rgba(255,255,255,1)');
      g.addColorStop(0.35, 'rgba(255,255,255,0.9)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(size/2,size/2,size/2,0,Math.PI*2); ctx.fill();
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    const roundSprite = makeCircleSprite();

    // ---------- ÓRBITAS com Line2 (espessura constante em pixels) ----------
    const orbitMaterials = [];
    function orbitCircle(radiusAU, hex=0x334155, linewidthPx=1.6, opacity=0.35){
      const segs = 512;
      const pts = [];
      const r = radiusAU*AU;
      for (let i=0;i<=segs;i++){
        const t = (i/segs)*Math.PI*2;
        pts.push(r*Math.cos(t), 0, r*Math.sin(t)); // plano XZ
      }
      const g = new LineGeometry(); g.setPositions(pts);
      const m = new LineMaterial({ color:hex, linewidth:linewidthPx, transparent:true, opacity });
      m.resolution.set(innerWidth, innerHeight);
      const line = new Line2(g, m);
      line.computeLineDistances();
      orbitMaterials.push(m);
      return line;
    }

    const orbitLines = new THREE.Group(); scene.add(orbitLines);
    const PLANET_SCALE = 0.15;
    const planets = [
      { name:'Mercúrio', a:0.39, color:0x9c9c9c },
      { name:'Vênus',   a:0.72, color:0xe1c16e },
      { name:'Terra',   a:1.00, color:0x6ab7ff },
      { name:'Marte',   a:1.52, color:0xff7755 },
      { name:'Júpiter', a:5.20, color:0xffd39b }
    ];
    const planetMeshes = [];
    planets.forEach(p=>{
      orbitLines.add(orbitCircle(p.a, 0x2a394b, 1.5, .35));
      const m = new THREE.Mesh(new THREE.SphereGeometry(PLANET_SCALE,28,28), new THREE.MeshStandardMaterial({ color:p.color, roughness:.6, metalness:.1 }));
      m.position.set(p.a*AU,0,0);
      m.userData = { type:'planet', name:p.name, a:p.a };
      planetMeshes.push(m); scene.add(m);
    });

    // ---------- POPULAÇÕES (pontos redondos) ----------
    function makePointCloud(positions, colorHex, size=0.06, opacity=0.9){
      const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const m = new THREE.PointsMaterial({ size, color:colorHex, transparent:true, opacity, depthWrite:false, map:roundSprite, alphaTest:0.5, sizeAttenuation:true });
      const pts = new THREE.Points(g, m); pts.frustumCulled = true;
      return pts;
    }

    // Cinturão Principal
    const BELT_COUNT = 2200;
    const beltPos = new Float32Array(BELT_COUNT*3);
    for (let i=0;i<BELT_COUNT;i++){
      const a = THREE.MathUtils.randFloat(2.2,3.2)*AU;
      const phi = Math.random()*Math.PI*2, z = THREE.MathUtils.randFloatSpread(0.25);
      beltPos[3*i]=a*Math.cos(phi); beltPos[3*i+1]=z; beltPos[3*i+2]=a*Math.sin(phi);
    }
    const belt = makePointCloud(beltPos, 0x7aa3ff, 0.07, 0.95);
    belt.userData = { region:'Cinturão Principal', comp:'C,S,M (escuros a rochosos)', size:'100 m – 500 km (poucos grandes)', rho:'~1.3–3.5 g/cm³', note:'Entre Marte e Júpiter (~2.2–3.2 AU)' };
    scene.add(belt);

    // Troianos L4/L5
    const TROJ_COUNT = 1200;
    const trojPos = new Float32Array(TROJ_COUNT*3);
    for (let i=0;i<TROJ_COUNT;i++){
      const which = Math.random()<0.5 ? +1 : -1;
      const base = (which>0 ? Math.PI/3 : -Math.PI/3);
      const dphi = THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(-15,15));
      const r = 5.2*THREE.MathUtils.randFloat(0.92,1.08)*AU;
      const phi = base + dphi;
      trojPos[3*i]=r*Math.cos(phi); trojPos[3*i+1]=THREE.MathUtils.randFloatSpread(0.18); trojPos[3*i+2]=r*Math.sin(phi);
    }
    const trojans = makePointCloud(trojPos, 0x00ff88, 0.075, 0.95);
    trojans.userData = { region:'Troianos de Júpiter', comp:'D/P (escuros e avermelhados)', size:'100 m – 200 km (raros ≥ 200 km)', rho:'~0.8–2.0 g/cm³', note:'Aglomerados em L4/L5 (±60° de Júpiter)' };
    scene.add(trojans);

    // OVERLAY L4/L5 (corrigido: no plano XZ)
    const trojanOverlay = new THREE.Group(); scene.add(trojanOverlay);
    function sector(radius, thetaStart, len, color){
      const mesh = new THREE.Mesh(
        new THREE.RingGeometry(radius-0.13, radius+0.13, 128, 1, thetaStart, len),
        new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.18, side:THREE.DoubleSide })
      );
      mesh.rotation.x = -Math.PI/2; // <<< FIX: alinha ao plano das órbitas (XZ)
      return mesh;
    }
    const L_SECTOR = Math.PI/6;
    trojanOverlay.add(sector(5.2*AU,  Math.PI/3 - L_SECTOR/2, L_SECTOR, 0x00ff88));
    trojanOverlay.add(sector(5.2*AU, -Math.PI/3 - L_SECTOR/2, L_SECTOR, 0x00ff88));

    // ---------- TRAJETÓRIA LUCY (sonda) ----------
    const lucyPts = [
      new THREE.Vector3(1*AU, 0, 0),
      new THREE.Vector3(2.3*AU, 0.5, 0.2),
      new THREE.Vector3(0.9*AU, -0.4, 0.0),
      new THREE.Vector3(5.2*AU*Math.cos(Math.PI/3), 0, 5.2*AU*Math.sin(Math.PI/3)),
      new THREE.Vector3(5.3*AU, 0.5, 0.3),
      new THREE.Vector3(1.1*AU, -0.8, 0.0),
      new THREE.Vector3(5.2*AU*Math.cos(-Math.PI/3), 0, 5.2*AU*Math.sin(-Math.PI/3))
    ];
    const lucyCurve = new THREE.CatmullRomCurve3(lucyPts, false, 'catmullrom', 0.15);
    const lucyPath = new THREE.Mesh(new THREE.TubeGeometry(lucyCurve, 800, 0.03, 8, false), new THREE.MeshBasicMaterial({ color:0xf6ad06, transparent:true, opacity:.9 }));
    scene.add(lucyPath);

    function makeTextSprite(text, color='#ffffff'){
      const c = document.createElement('canvas'); c.width=256; c.height=64;
      const ctx = c.getContext('2d'); ctx.font='28px Inter, sans-serif'; ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle = color; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=6;
      ctx.fillText(text, c.width/2, c.height/2);
      const t = new THREE.CanvasTexture(c); t.colorSpace = THREE.SRGBColorSpace; return t;
    }

    function makeLucyCraft(){
      const g = new THREE.Group();
      const bus = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.07,0.18,16), new THREE.MeshStandardMaterial({ color:0x8c5516, metalness:0.6, roughness:0.3 }));
      bus.rotation.z = Math.PI/2; g.add(bus);
      const hga = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.01,24), new THREE.MeshStandardMaterial({ color:0x333333, emissive:0x111111, roughness:0.7 }));
      g.add(hga);
      const panelMat = new THREE.MeshStandardMaterial({ color:0x1d8ff5, emissive:0x0b2d6b, emissiveIntensity:0.35, metalness:0.2, roughness:0.5 });
      const p1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.55, 0.28), panelMat);
      const p2 = p1.clone(); p1.position.set(0,0,0.23); p2.position.set(0,0,-0.23); g.add(p1,p2);
      const lamp = new THREE.PointLight(0xf6ad06, 0.9, 3); lamp.position.set(0.08, 0, 0); g.add(lamp);
      const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeTextSprite('Lucy', '#f6ad06'), transparent:true, depthWrite:false }));
      label.scale.set(1.2,0.35,1); label.position.set(0.0, 0.6, 0); g.add(label);
      return g;
    }
    const lucy = makeLucyCraft(); scene.add(lucy);
    let lucyT = 0.0;

    // ---------- INTERAÇÃO ----------
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points = { threshold: 0.15 };
    const pickables = [belt, trojans, ...planetMeshes, kuiperPlaceholder()]; // (placeholder se quiser ativar Kuiper real depois)
    function kuiperPlaceholder(){ const o = new THREE.Object3D(); o.visible=false; o.userData={region:'Cinturão de Kuiper',comp:'gelo + rocha (C/D)',size:'km–1000 km',rho:'~0.5–2.0 g/cm³',note:'Além de Netuno (~30–50 AU)'}; return o; }

    const $ = (s)=>document.querySelector(s);
    const selTitle=$('#selTitle'), selGrid=$('#selGrid'), infoCard=$('#infoCard');

    function setSelected(title, kv){
      selTitle.textContent = title;
      const lines = [
        ['Região', kv.region ?? '—'],
        ['Composição típica', kv.comp ?? '—'],
        ['Tamanho típico', kv.size ?? '—'],
        ['Densidade típica', kv.rho ?? '—'],
        ['Notas', kv.note ?? '—']
      ];
      selGrid.innerHTML = lines.map(([k,v])=>`<div>${k}</div><div>${v}</div>`).join('');
      // espelha no dat.gui
      guiState.selection.Título = title;
      guiState.selection.Região = kv.region ?? '—';
      guiState.selection.Composição = kv.comp ?? '—';
      guiState.selection.Tamanho = kv.size ?? '—';
      guiState.selection.Densidade = kv.rho ?? '—';
      guiState.selection.Notas = kv.note ?? '—';
      for (const c of selControllers) c.updateDisplay();
    }

    function onPointerDown(ev){
      const r = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2(((ev.clientX-r.left)/r.width)*2-1, -(((ev.clientY-r.top)/r.height)*2-1));
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(pickables, false);
      if(!hits.length) return;
      const h = hits[0];
      if (h.object === belt || h.object === trojans || h.object.userData?.region==='Cinturão de Kuiper'){
        setSelected(h.object.userData.region, h.object.userData);
      } else {
        const p = planetMeshes.find(m=>m===h.object);
        if (p) setSelected(p.userData.name, { region:'Planeta', comp:'—', size:'—', rho:'—', note:'Referência de escala/órbita' });
      }
    }
    renderer.domElement.addEventListener('pointerdown', onPointerDown);

    // ---------- GRUPOS/ANIMAÇÃO ----------
    const beltGroup = new THREE.Group(); beltGroup.add(belt); scene.add(beltGroup);
    const trojGroup = new THREE.Group(); trojGroup.add(trojans,trojanOverlay); scene.add(trojGroup);
    beltGroup.rotation.y = 0.25; trojGroup.rotation.y = 0.0;

    // ---------- DAT.GUI ----------
    const gui = new dat.GUI({ name:'Looking for Asteroids' });

    const guiState = {
      view: { cameraMode: 'Orbit (persp)', pointSize: 1.0, spinSpeed: 1.0, showOrbits: true },
      layers: { Belt: true, Trojans: true, Kuiper: false, Lucy: true, InfoCard: false },
      lucy: { speed: 1.0, progress: 0.0 },
      selection: { 'Título':'—', 'Região':'—', 'Composição':'—', 'Tamanho':'—', 'Densidade':'—', 'Notas':'—' }
    };

    const fView = gui.addFolder('View');
    fView.add(guiState.view, 'cameraMode', ['Orbit (persp)','Top (ortho)']).name('Câmera').onChange(setCameraMode);
    fView.add(guiState.view, 'pointSize', 0.5, 2.0, 0.05).name('Tamanho dos pontos').onChange(v=>{
      [belt,trojans].forEach(pts=>{ pts.material.size = 0.07*v; pts.material.needsUpdate=true; });
    });
    fView.add(guiState.view, 'spinSpeed', 0.1, 2.0, 0.05).name('Velocidade de giro');
    fView.add(guiState.view, 'showOrbits').name('Órbitas dos planetas').onChange(v=> orbitLines.visible=v );
    fView.open();

    const fLayers = gui.addFolder('Camadas');
    fLayers.add(guiState.layers, 'Belt').name('Cinturão Principal').onChange(v=> belt.visible=v);
    fLayers.add(guiState.layers, 'Trojans').name('Troianos L4/L5').onChange(v=>{ trojans.visible=v; trojanOverlay.visible=v; });
    fLayers.add(guiState.layers, 'Kuiper').name('Cinturão de Kuiper').onChange(v=> pickables.find(o=>o.userData?.region==='Cinturão de Kuiper').visible=v);
    fLayers.add(guiState.layers, 'Lucy').name('Lucy (trajetória)').onChange(v=> { lucy.visible=v; lucyPath.visible=v; });
    fLayers.add(guiState.layers, 'InfoCard').name('Mostrar caixa Seleção').onChange(v=> infoCard.style.display = v ? 'block' : 'none');
    fLayers.open();

    const fLucy = gui.addFolder('Lucy (trajetória)');
    fLucy.add(guiState.lucy, 'speed', 0.2, 3.0, 0.05).name('Velocidade');
    fLucy.add(guiState.lucy, 'progress', 0, 1, 0.001).name('Progresso 0..1').onChange(v => { lucyT = v; });
    fLucy.open();

    const fSel = gui.addFolder('Seleção (técnico)');
    const selControllers = [
      fSel.add(guiState.selection, 'Título').listen(),
      fSel.add(guiState.selection, 'Região').listen(),
      fSel.add(guiState.selection, 'Composição').listen(),
      fSel.add(guiState.selection, 'Tamanho').listen(),
      fSel.add(guiState.selection, 'Densidade').listen(),
      fSel.add(guiState.selection, 'Notas').listen()
    ];
    fSel.open();

    // ---------- LOOP ----------
    function animate(){
      requestAnimationFrame(animate);

      const s = 0.0006 * guiState.view.spinSpeed;
      beltGroup.rotation.y += s;
      trojGroup.rotation.y += s;

      lucyT = (lucyT + 0.00028*guiState.lucy.speed) % 1;
      const pos = lucyCurve.getPointAt(lucyT);
      const tangent = lucyCurve.getTangentAt(lucyT).normalize();
      lucy.position.copy(pos);
      lucy.lookAt(pos.clone().add(tangent));
      lucy.rotateX(Math.PI/2);

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---------- RESIZE ----------
    function onResize(){
      const aspect = innerWidth/innerHeight;
      camPersp.aspect = aspect; camPersp.updateProjectionMatrix();

      const size = orthoSize;
      camOrtho.left = -size*aspect; camOrtho.right = size*aspect; camOrtho.top = size; camOrtho.bottom = -size;
      camOrtho.updateProjectionMatrix();

      orbitMaterials.forEach(m => m.resolution.set(innerWidth, innerHeight)); // mantém linewidth em px
      renderer.setSize(innerWidth, innerHeight);
    }
    addEventListener('resize', onResize);

    // Estado inicial
    setSelected('Clique em uma região/asteroide', {});
  </script>
</body>
</html>
