<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <title>Impactor-2025 Mitigation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <!-- dat.GUI -->
  <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

          <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2NRVS8C43B"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2NRVS8C43B');
</script>
  <!-- Import map: resolve "three" no browser -->
  <script type="importmap">
  {"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"}}
  </script>

  <style>
    :root{ --fg:#e6f1ff; --fg-dim:#b7c6e0; --laser:#ff5d5d; --tractor:#9cff9c; }
    html,body{height:100%; margin:0; background:#000; color:var(--fg);
      font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; overflow:hidden}
    .stars{position:fixed; inset:0; background:
      radial-gradient(2px 2px at 20% 30%, #fff6 50%, #0000 51%),
      radial-gradient(1px 1px at 70% 80%, #fff8 50%, #0000 51%),
      radial-gradient(1px 1px at 40% 60%, #fff8 50%, #0000 51%),
      radial-gradient(2px 2px at 80% 20%, #fff6 50%, #0000 51%),
      radial-gradient(1px 1px at 30% 85%, #fff7 50%, #0000 51%),
      radial-gradient(1px 1px at 60% 10%, #fff9 50%, #0000 51%),
      #000; animation:twinkle 6s linear infinite; z-index:0}
    @keyframes twinkle{0%,100%{filter:brightness(1)} 50%{filter:brightness(1.25)}}
    header{position:fixed; top:0; left:0; right:360px; padding:16px 20px; z-index:3; pointer-events:none;
      background:linear-gradient(180deg,#000a,#0000)}
    header h1{margin:0; font-weight:800}
    header p{margin:.3rem 0 0; color:var(--fg-dim); max-width:1000px}
    .tag{display:inline-block; padding:.2rem .5rem; margin-right:.5rem; border:1px solid #ffffff22; border-radius:999px;
      font-size:.75rem; color:var(--fg-dim)}
    .wrap{position:fixed; inset:0 360px 0 300px; z-index:1} /* área 3D central */
    #scene{width:100%; height:100%}

    aside#ui-left{
      position:fixed; top:0; left:0; width:300px; height:100%;
      background:#05070c; border-right:1px solid #0f1a2f;
      z-index:2; overflow:auto; padding:8px 6px 80px 6px;
    }
    aside#ui{
      position:fixed; top:0; right:0; width:360px; height:100%;
      background:#05070c; border-left:1px solid #0f1a2f;
      z-index:2; overflow:auto; padding:8px 6px 80px 6px;
    }
    header{left:300px; right:360px;}
    .wrap{position:fixed; inset:0 360px 0 300px; z-index:1}

    /* Ajustar ambos painéis dat.GUI */
    #pane .dg.main,
    #pane-left .dg.main{width:100% !important; box-sizing:border-box}
    #pane .dg.main::-webkit-scrollbar,
    #pane-left .dg.main::-webkit-scrollbar{width:8px}
    #pane .dg.main::-webkit-scrollbar-thumb,
    #pane-left .dg.main::-webkit-scrollbar-thumb{background:#223246}

    /* Blocos customizados (dentro de folders) */
    .dg .kpi-grid{display:grid; grid-template-columns:1fr 1fr; gap:6px; margin:6px 0 4px}
    .dg .kpi-item{background:#0b111a; border:1px solid #1e2b3c; padding:6px 6px 4px; border-radius:4px;
      font:11px/1.3 'Lucida Grande',Tahoma,Arial,sans-serif; color:#d8e4f5}
    .dg .kpi-item span{display:block; font-size:10px; opacity:.65; margin-bottom:2px}
    .dg .kpi-item b{font-weight:600; font-size:12px}

    .dg .svg-row{display:grid; grid-template-columns:1fr 1fr; gap:6px; margin:6px 0} /* <- remover esta linha se quiser */
    .dg .svg-box{background:#0b111a; border:1px solid #1e2b3c; border-radius:4px; padding:4px} /* <- remover esta linha se quiser */
    /* === novas classes para imagens === */
    .dg .img-grid{display:grid; grid-template-columns:1fr 1fr; gap:6px; margin:6px 0}
    .dg .img-box{background:#0b111a; border:1px solid #1e2b3c; border-radius:4px; padding:0; position:relative; overflow:hidden; aspect-ratio:16/11}
    .dg .img-box img{width:100%; height:100%; object-fit:cover; display:block; filter:brightness(.95) contrast(1.05)}
    .dg .img-box span.label{position:absolute; top:6px; left:10px; font-size:11px; font-weight:600; letter-spacing:.5px; color:#e6f1ff; text-shadow:0 0 4px #000}

    /* Charts dentro do dat.GUI */
    .dg .chart-box{position:relative; height:220px; background:#0b111a; border:1px solid #1e2b3c; border-radius:4px; overflow:hidden; margin-bottom:4px}
    .dg .chart-box > canvas{width:100% !important; height:100% !important; display:block}

    footer{position:fixed; left:0; right:360px; bottom:0; padding:6px 12px;
      font-size:12px; background:linear-gradient(180deg,#0000,#000a); pointer-events:none; color:#7f91a6}

    .dg .cr.custom-block{background:none; border:0; padding:0; height:auto}
    .dg .cr.custom-block:hover{background:none}
  </style>
</head>
<body>
  <div class="stars" aria-hidden="true"></div>

  <header>
    <span class="tag">Meteor Madness</span>
   
    <h1>Impactor-2025 ( Gravity Tractor & Laser Ablation )</h1>
    <p>Rotate the 3D asteroid, activate deflection methods, and view <em>deflection</em> and <em>ablation</em> charts.</p>
  </header>

  <div class="wrap"><div id="scene"></div></div>

  <aside id="ui-left">
    <div id="pane-left"></div>
  </aside>
  <aside id="ui">
    <div id="pane"></div>
  </aside>

  <footer>Rotate with the mouse (drag), scroll to zoom. Use the buttons to simulate <b>Laser</b> and <b>Tractor</b>.</footer>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const Chart = window.Chart;

    // ===== Cena 3D =====
    const container = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 5.7; // mais brilho geral

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, container.clientWidth/container.clientHeight, 0.1, 2000);
    camera.position.set(0, 1.4, 4);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0,0,0);
    controls.enablePan = false;
    controls.zoomSpeed = 0.6; // (não usado mais, zoom custom)
    controls.enableZoom = false; // desativa zoom padrão agressivo

    // Luzes
    const hemi = new THREE.HemisphereLight(0xd2e3ff, 0x111317, 1.35); scene.add(hemi);
    const ambient = new THREE.AmbientLight(0xffffff, 0.28); scene.add(ambient); // luz suave global
    const dir = new THREE.DirectionalLight(0xffffff, 1.10); dir.position.set(5,4,3); dir.castShadow=true; scene.add(dir);
    const fill = new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-4,2,-3); scene.add(fill);
    const rim  = new THREE.DirectionalLight(0xffc28a, 0.30); rim.position.set(2,-3,4); scene.add(rim);

    // Estrelas
    const starGeo = new THREE.BufferGeometry();
    const N = 1000, pts = new Float32Array(N*3);
    for(let i=0;i<N;i++){
      const r=80+Math.random()*80, th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
      pts[i*3+0]=r*Math.sin(ph)*Math.cos(th);
      pts[i*3+1]=r*Math.sin(ph)*Math.sin(th);
      pts[i*3+2]=r*Math.cos(ph);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(pts,3));
    scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size:.4, color:0x9fb8ff, transparent:true, opacity:.75 })));

    // ===== asteroid (replicando lógica do projeto Particulas) =====
    // Gera geometria esférica com ruído + crateras similar à versão Particulas
    function createRealisticAsteroidGeometry(radius, detail){
      const geometry = new THREE.SphereGeometry(radius, detail, Math.max(8, detail/2));
      const verts = geometry.attributes.position.array;
      const vTmp = new THREE.Vector3();

      const applyPseudoNoise = (verts,freq,mag)=>{
        for(let i=0;i<verts.length;i+=3){
          vTmp.set(verts[i],verts[i+1],verts[i+2]);
          let d=0;
            d+=Math.sin(vTmp.x*freq)*Math.sin(vTmp.y*freq)*Math.sin(vTmp.z*freq);
            d+=0.5*Math.sin(vTmp.y*freq*2.1)*Math.sin(vTmp.z*freq*2.1)*Math.sin(vTmp.x*freq*2.1);
          d*=mag;
          const n=vTmp.clone().normalize();
          vTmp.add(n.multiplyScalar(d));
          verts[i]=vTmp.x; verts[i+1]=vTmp.y; verts[i+2]=vTmp.z;
        }
      };
      const addCrater=(verts,center,r,depth)=>{
        const r2=r*r;
        for(let i=0;i<verts.length;i+=3){
          vTmp.set(verts[i],verts[i+1],verts[i+2]);
          const distSq = vTmp.distanceToSquared(center);
          if(distSq<r2){
            const fall=1-distSq/r2;
            const smooth=fall*fall*(3-2*fall);
            const disp=center.clone().normalize().multiplyScalar(-depth*smooth);
            vTmp.add(disp);
            verts[i]=vTmp.x; verts[i+1]=vTmp.y; verts[i+2]=vTmp.z;
          }
        }
      };

      applyPseudoNoise(verts,1.2,radius*0.15);
      applyPseudoNoise(verts,2.5,radius*0.05);
      for(let c=0;c<15;c++){
        const theta=Math.random()*Math.PI*2;
        const phi = Math.acos(Math.random()*2-1);
        const center=new THREE.Vector3(
          radius*Math.sin(phi)*Math.cos(theta),
          radius*Math.sin(phi)*Math.sin(theta),
          radius*Math.cos(phi)
        );
        const cr=radius*(Math.random()*0.25+0.1);
        const cd=cr*(Math.random()*0.5+0.2);
        addCrater(verts,center,cr,cd);
      }

      geometry.attributes.position.needsUpdate=true;
      geometry.computeVertexNormals();
      geometry.computeBoundingSphere();
      return geometry;
    }

    // --- Carregamento de texturas com debug e correção de color space ---
    const texPath = '../Particulas/';
    const texLoader = new THREE.TextureLoader();
    texLoader.setPath(texPath);

    let texCount = 0;
    const asteroidTextures = {};
    function done(){ if(++texCount===4) buildAsteroidMesh(); }
    function fail(url){ console.warn('Falha ao carregar textura:', url); done(); }

    function load(name, isColor=false){
      return texLoader.load(name,
        t=>{
          if(isColor) t.colorSpace = THREE.SRGBColorSpace; else t.colorSpace = THREE.LinearSRGBColorSpace;
          t.wrapS = t.wrapT = THREE.RepeatWrapping;
          t.anisotropy = renderer.capabilities.getMaxAnisotropy();
          done();
        },
        undefined,
        ()=>fail(name)
      );
    }

    asteroidTextures.diffuse   = load('texture_pbr_20250901.png', true);
    asteroidTextures.normal    = load('texture_pbr_20250901_normal.png');
    asteroidTextures.roughness = load('texture_pbr_20250901_roughness.png');
    asteroidTextures.metallic  = load('texture_pbr_20250901_metallic.png');

    // Placeholder (mantenha)
    let asteroid = new THREE.Mesh(
      new THREE.SphereGeometry(1,16,12),
      new THREE.MeshStandardMaterial({ color:0x666666, roughness:1 })
    );
    asteroid.castShadow = asteroid.receiveShadow = true;
    scene.add(asteroid);

    // --- Nova função buildAsteroidMesh usando PBR (Standard) ---
    function buildAsteroidMesh(){
      const mat = new THREE.MeshStandardMaterial({
        map: asteroidTextures.diffuse || null,
        normalMap: asteroidTextures.normal || null,
        roughness: 0.95,     // quase totalmente difuso
        metalness: 0.3,      // sem reflexão metálica
        flatShading: false
      });
      if(mat.map) mat.map.colorSpace = THREE.SRGBColorSpace;

      // Clarear bastante a cor base (sem depender de metalness)
      mat.color.set(0xffffff).multiplyScalar(1.8);

      // Opcional: reforçar luz em áreas escuras simulando AO invertido
      mat.onBeforeCompile = shader=>{
        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <dithering_fragment>',
          `
            // Levanta tons médios (curva suave)
            vec3 lifted = mix(vec3(0.0), outgoingLight, 0.92);
            outgoingLight = max(outgoingLight, lifted);
            #include <dithering_fragment>
          `
        );
      };

      const geo = createRealisticAsteroidGeometry(1,96);
      const newAst = new THREE.Mesh(geo, mat);
      newAst.castShadow = newAst.receiveShadow = true;

      while(asteroid.children.length){
        newAst.add(asteroid.children[0]);
      }
      scene.remove(asteroid);
      asteroid = newAst;
      scene.add(asteroid);

      updateMethodPositions();
      updateOrbitLimits();
      rebuildAsteroid();
    }

    // Indicadores Laser/Tractor
    const laser = new THREE.Mesh(new THREE.CylinderGeometry(0.01,0.01,2.2,12), new THREE.MeshBasicMaterial({ color:0xff5d5d }));
    laser.rotation.z = Math.PI/2; laser.position.set(-1.6,0.05,0); laser.visible=false; scene.add(laser);
    const glow = new THREE.Mesh(new THREE.SphereGeometry(0.06,16,16), new THREE.MeshBasicMaterial({ color:0xffb36b }));
    glow.position.set(1,0,0); glow.visible=false; asteroid.add(glow);

    const ship = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.08,0.08), new THREE.MeshStandardMaterial({ color:0x9cff9c, emissive:0x103010 }));
    ship.position.set(1.8,0.2,0); ship.visible=false; scene.add(ship);
    const tractorLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(1.8,0.2,0), new THREE.Vector3(1.1,0.1,0)]),
      new THREE.LineBasicMaterial({ color:0x9cff9c })
    ); tractorLine.visible=false; scene.add(tractorLine);

    const BASE_LASER_LEN = 2.2;          // altura original do cilindro (eixo Y antes da rotação)
    const LASER_LEN_FACTOR = 0.58;       // fração do diâmetro em X usada como comprimento do feixe
    const LASER_SURFACE_INSET = 0.0;     // leve valor positivo empurra ponta um pouco “dentro” do asteroid (ex: 0.002)
    const TRACTOR_OFFSET_FACTOR = 0.45;  // fração do diâmetro em X para posicionar a nave além da superfície

    function getAsteroidExtents(){
      if(!asteroid || !asteroid.geometry?.attributes?.position) return {minX:-1,maxX:1,sizeX:2};
      const pos = asteroid.geometry.attributes.position;
      let minX=Infinity, maxX=-Infinity;
      for(let i=0;i<pos.count;i++){
        const x = pos.getX(i);
        if(x<minX) minX=x;
        if(x>maxX) maxX=x;
      }
      const s = asteroid.scale.x;
      return { minXWorld:minX*s, maxXWorld:maxX*s, sizeX:(maxX-minX)*s, minXLocal:minX, maxXLocal:maxX };
    }

    function updateMethodPositions(){
      if(!asteroid) return;
      if(!asteroid.geometry.boundingSphere) asteroid.geometry.computeBoundingSphere();

      const { minXWorld, maxXWorld, sizeX, maxXLocal, minXLocal } = getAsteroidExtents();

      // ===== LASER (lado -X) =====
      const laserLen = sizeX * LASER_LEN_FACTOR;
      const innerTip = minXWorld + LASER_SURFACE_INSET * sizeX;  // ponto que toca a superfície
      const centerX  = innerTip - laserLen/2;                    // centro do cilindro
      laser.scale.set(1, laserLen / BASE_LASER_LEN, 1);
      laser.position.set(centerX, 0.05*sizeX, 0);

      // ===== GLOW (lado +X) =====
      // Glow é filho do asteroide: usar coordenada local máxima em X (já alinhado ao formato real)
      glow.position.set(maxXLocal, 0, 0);

      // ===== GRAVITY TRACTOR (lado +X) =====
      const tractorOut = sizeX * TRACTOR_OFFSET_FACTOR;
      const innerX = maxXWorld;                 // ponto na superfície real
      const shipX  = maxXWorld + tractorOut;    // nave além
      ship.position.set(shipX, 0.10*sizeX, 0);

      if(tractorLine.geometry && tractorLine.geometry.attributes.position){
        const posAttr = tractorLine.geometry.attributes.position;
        // ponto 0 = nave externa, ponto 1 = superfície
        posAttr.setXYZ(0, shipX, 0.10*sizeX, 0);
        posAttr.setXYZ(1, innerX, 0.05*sizeX, 0);
        posAttr.needsUpdate = true;
      }
    }

    // ===== Modelo =====
    const state = {
      asteroid:{ diameter_km:.39, density:2250, albedo:.02, spin_rps:.060 },
      approach:{ lead_time_days:1095, rel_velocity_kms:15.0 },
      laser:{ power_MW:2.0, duty_cycle:.70 },
      tractor:{ ship_mass_ton:10, standoff_m:150 },
      toggles:{ laser:false, tractor:false }
    };
    function asteroidMass(){ const r=(state.asteroid.diameter_km*1000)/2; return (4/3)*Math.PI*r*r*r*state.asteroid.density; }
    function estimateDeflectionKm(){
      const m=asteroidMass(), t=state.approach.lead_time_days*86400; let a=0;
      if(state.toggles.laser){ const k=.0008, ve=3000; const mdot=k*(state.laser.power_MW*1e6)*state.laser.duty_cycle*1e-6; a+=(mdot*ve)/m; }
      if(state.toggles.tractor){ const G=6.674e-11, M=state.tractor.ship_mass_ton*1000, r=state.tractor.standoff_m; a += (G*M*asteroidMass()/(r*r))/m; }
      return 0.5*a*t*t/1000;
    }
    function estimateMassLossTon(){ return state.toggles.laser ? state.laser.power_MW*.35*state.laser.duty_cycle*state.approach.lead_time_days : 0; }

    // ===== GUIs =====
    const guiRight = new dat.GUI({ autoPlace:false, width:340 }); // Indicadores + Imagens + Gráficos
    document.getElementById('pane').appendChild(guiRight.domElement);

    const guiLeft  = new dat.GUI({ autoPlace:false, width:280 }); // Parâmetros
    document.getElementById('pane-left').appendChild(guiLeft.domElement);

    function rebuildAsteroid(){
      const s=(state.asteroid.diameter_km*1000)/450;
      asteroid.scale.setScalar(Math.max(.2,s));
      if(!asteroid.geometry.boundingSphere) asteroid.geometry.computeBoundingSphere();
      updateMethodPositions();
      updateOrbitLimits();
    }

    // ===== Zoom suave personalizado =====
    let targetDistance = camera.position.distanceTo(controls.target);

    function applySmoothZoom(){
      const cur = camera.position.distanceTo(controls.target);
      const newDist = cur + (targetDistance - cur)*0.12; // fator de suavização
      const dir = camera.position.clone().sub(controls.target).normalize();
      camera.position.copy(dir.multiplyScalar(newDist).add(controls.target));
    }

    function onWheel(e){
      e.preventDefault();
      const dy = e.deltaY;
      // fator pequeno proporcional ao delta (log/linear híbrido)
      const scale = 1 + Math.min(Math.abs(dy)/600, 0.35); // limite máx passo
      if(dy > 0){
        targetDistance = Math.min(targetDistance * scale, controls.maxDistance);
      }else{
        targetDistance = Math.max(targetDistance / scale, controls.minDistance);
      }
    }
    renderer.domElement.addEventListener('wheel', onWheel, { passive:false });

    function updateOrbitLimits(){
      const r = (asteroid.geometry.boundingSphere?.radius || 1) * asteroid.scale.x;
      // faixa mais útil (antes estava até 60x)
      controls.minDistance = r * 1.25;
      controls.maxDistance = r * 14.0;
      // garante alvo dentro dos limites
      targetDistance = THREE.MathUtils.clamp(
        targetDistance,
        controls.minDistance * 1.01,
        controls.maxDistance * 0.99
      );
    }

    // ===== Folders Parâmetros (GUI ESQUERDA) =====
    const fAst = guiLeft.addFolder('Asteroid');
    fAst.add(state.asteroid,'diameter_km',0.05,1.5,0.01).name('Diameter (km)').onChange(()=>{ rebuildAsteroid(); updateDash(); });
    fAst.add(state.asteroid,'density',1200,4500,50).name('Density').onChange(updateDash);
    fAst.add(state.asteroid,'spin_rps',0,0.1,0.005).name('Rotation (rps)');

    const fL = guiLeft.addFolder('Laser Ablation');
    fL.add(state.laser,'power_MW',0,10,0.1).name('Power (MW)').onChange(updateDash);
    fL.add(state.laser,'duty_cycle',0,1,0.05).name('Duty Cycle').onChange(updateDash);

    const fT = guiLeft.addFolder('Gravity Tractor');
    fT.add(state.tractor,'ship_mass_ton',1,80,1).name('Ship Mass').onChange(updateDash);
    fT.add(state.tractor,'standoff_m',50,600,5).name('Distance (m)').onChange(updateDash);

    const fOn = guiLeft.addFolder('Active');
    fOn.add(state.toggles,'laser').name('Laser ON').onChange(v=>{ laser.visible = glow.visible = v; updateDash(); });
    fOn.add(state.toggles,'tractor').name('Tractor ON').onChange(v=>{ ship.visible = tractorLine.visible = v; updateDash(); });

    const actions = {
      Resetar: ()=>{
        Object.assign(state.asteroid,{ diameter_km:.39, density:2250, albedo:.02, spin_rps:.060 });
        Object.assign(state.approach,{ lead_time_days:1095, rel_velocity_kms:15.0 });
        Object.assign(state.laser,{ power_MW:2.0, duty_cycle:.70 });
        Object.assign(state.tractor,{ ship_mass_ton:10, standoff_m:150 });
        state.toggles.laser=false; state.toggles.tractor=false;
        laser.visible=glow.visible=ship.visible=tractorLine.visible=false;
        rebuildAsteroid(); updateDash();
        updateAllDisplays();
      }
    };
    guiLeft.add(actions,'Resetar');

    function updateAllDisplays(){
      [...guiLeft.__controllers, ...Object.values(guiLeft.__folders).flatMap(f=>f.__controllers)]
        .forEach(c=>c.updateDisplay());
    }

    // ===== Analytical Folders (RIGHT GUI) =====
    const fKPI = guiRight.addFolder('Indicators');
    const kpiLi = document.createElement('li'); kpiLi.className='cr custom-block';
    kpiLi.innerHTML = `
      <div class="kpi-grid">
      <div class="kpi-item"><span>Estimated deflection (km)</span><b id="kpiDeflection">—</b></div>
      <div class="kpi-item"><span>Mass lost (ton)</span><b id="kpiMassLoss">—</b></div>
      </div>`;
    fKPI.__ul.appendChild(kpiLi);

    const fIll = guiRight.addFolder('Illustrations');
    const illLi = document.createElement('li'); illLi.className='cr custom-block';
    illLi.innerHTML = `
      <div class="img-grid">
      <div class="img-box"><img src="assets/gravity-tractor.png" alt="Gravity Tractor"></div>
      <div class="img-box"><img src="assets/laser-ablation.png" alt="Laser Ablation"></div>
      </div>
      <p class="note">Demonstrative images.</p>`;
    fIll.__ul.appendChild(illLi);

    const fDef = guiRight.addFolder('Chart: Deflection vs Time');
    const defLi = document.createElement('li'); defLi.className='cr custom-block';
    defLi.innerHTML = `
      <div class="legend">
      <span class="dot laser"></span><span class="note" style="margin:0">Laser</span>
      <span class="dot tractor"></span><span class="note" style="margin:0">Tractor</span>
      </div>
      <div class="chart-box"><canvas id="chartDeflect"></canvas></div>
      <p class="note">Simplified curves.</p>`;
    fDef.__ul.appendChild(defLi);

    const fAblF = guiRight.addFolder('Chart: Ablation vs Time');
    const ablLi = document.createElement('li'); ablLi.className='cr custom-block';
    ablLi.innerHTML = `
      <div class="chart-box"><canvas id="chartAblation"></canvas></div>
      <p class="note">Dependent on power.</p>`;
    fAblF.__ul.appendChild(ablLi);

    // Garanta que nenhuma linha anterior está fechando os folders.
    // Abra todas as abas por padrão:
    [fAst, fL, fT, fOn, fKPI, fIll, fDef, fAblF].forEach(f=>f.open());

    // ===== Gráficos =====
    const ctxDeflect = document.getElementById('chartDeflect');
    const ctxAbl = document.getElementById('chartAblation');
    let chartDeflect, chartAblation;

    function computeDeflectionSeries(monthsList){
      const saveL=state.toggles.laser, saveT=state.toggles.tractor;
      const laserY=[], tractorY=[];
      for(const mths of monthsList){
        const saveDays=state.approach.lead_time_days; state.approach.lead_time_days=mths*30;
        state.toggles.laser=true; state.toggles.tractor=false; laserY.push(Number(estimateDeflectionKm().toFixed(2)));
        state.toggles.laser=false; state.toggles.tractor=true; tractorY.push(Number(estimateDeflectionKm().toFixed(2)));
        state.approach.lead_time_days=saveDays;
      }
      state.toggles.laser=saveL; state.toggles.tractor=saveT;
      return {laserY, tractorY};
    }
    function massLossAt(days){ const save=state.approach.lead_time_days; state.approach.lead_time_days=days; const v=estimateMassLossTon(); state.approach.lead_time_days=save; return Number(v.toFixed(2)); }

    function buildCharts(){
      const months=[1,3,6,12,24,36,60];
      const {laserY,tractorY}=computeDeflectionSeries(months);
      chartDeflect = new Chart(ctxDeflect,{
        type:'line',
        data:{ labels:months.map(m=>m+'m'),
          datasets:[
            {label:'Laser', data:laserY, borderColor:'#ff5d5d', backgroundColor:'#ff5d5d20', tension:.25},
            {label:'Tractor', data:tractorY, borderColor:'#9cff9c', backgroundColor:'#9cff9c20', tension:.25}
          ]},
        options:{ responsive:true, maintainAspectRatio:false,
          scales:{ y:{ title:{display:true,text:'Deflexão (km)'} }, x:{ title:{display:true,text:'Antecedência'} } },
          plugins:{ legend:{display:false} }
        }
      });

      const tDays = Array.from({length:10},(_,i)=>(i+1)*Math.round(state.approach.lead_time_days/10));
      chartAblation = new Chart(ctxAbl,{
        type:'bar',
        data:{ labels:tDays.map(d=>Math.round(d/30)+'m'),
          datasets:[{label:'Massa removida', data:tDays.map(massLossAt), backgroundColor:'#ffa94d'}]},
        options:{ responsive:true, maintainAspectRatio:false,
          scales:{ y:{ title:{display:true,text:'ton'} }, x:{ title:{display:true,text:'Tempo'} } },
          plugins:{ legend:{display:false} }
        }
      });
    }

    function updateCharts(){
      if(!chartDeflect || !chartAblation) return;
      const months=[1,3,6,12,24,36,60];
      const {laserY,tractorY}=computeDeflectionSeries(months);
      chartDeflect.data.datasets[0].data=laserY;
      chartDeflect.data.datasets[1].data=tractorY;
      chartDeflect.update();

      const tDays = Array.from({length:10},(_,i)=>(i+1)*Math.round(state.approach.lead_time_days/10));
      chartAblation.data.labels=tDays.map(d=>Math.round(d/30)+'m');
      chartAblation.data.datasets[0].data=tDays.map(massLossAt);
      chartAblation.update();
    }
    function updateDash(){
      document.getElementById('kpiDeflection').textContent = estimateDeflectionKm().toFixed(2);
      document.getElementById('kpiMassLoss').textContent   = estimateMassLossTon().toFixed(2);
      updateCharts();
    }

    // Loop / resize
    function animate(){ requestAnimationFrame(animate);
      asteroid.rotation.y += state.asteroid.spin_rps*(Math.PI*2)*(1/60);
      applySmoothZoom(); // aplica interpolação de zoom
      controls.update();
      renderer.render(scene,camera);
    }
    function onResize(){ const w=container.clientWidth,h=container.clientHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); }
    window.addEventListener('resize', onResize);

    // Init
    rebuildAsteroid(); updateOrbitLimits();
    targetDistance = camera.position.distanceTo(controls.target); // inicializa
    buildCharts(); updateDash(); animate();
    let t=0; setInterval(()=>{ t+=.1; if(laser.visible){ glow.scale.setScalar(1+.25*Math.sin(t*2)); } if(ship.visible){ ship.position.y=0.2+0.05*Math.sin(t*1.8); } },60);
    updateMethodPositions();
  </script>
</body>
</html>
